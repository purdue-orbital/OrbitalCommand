import {
  fade
} from "./chunk-4COOWGDQ.js";
import "./chunk-M6MB33T7.js";
import {
  svelte_exports
} from "./chunk-OSHTMI7F.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  check_outros,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  space,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-ADH6JJW2.js";

// node_modules/svelte-simple-modal/src/Modal.svelte
var { Object: Object_1, window: window_1 } = globals;
var file = "node_modules/svelte-simple-modal/src/Modal.svelte";
function add_css(target) {
  append_styles(target, "svelte-yxa4ka", ".svelte-yxa4ka{box-sizing:border-box}.bg.svelte-yxa4ka{position:fixed;z-index:1000;top:0;left:0;display:flex;flex-direction:column;justify-content:center;width:100vw;height:100vh;background:rgba(0, 0, 0, 0.66)}@supports (-webkit-touch-callout: none){}.wrap.svelte-yxa4ka{position:relative;margin:2rem;max-height:100%}.window.svelte-yxa4ka{position:relative;width:40rem;max-width:100%;max-height:100%;margin:2rem auto;color:black;border-radius:0.5rem;background:white}.content.svelte-yxa4ka{position:relative;padding:1rem;max-height:calc(100vh - 4rem);overflow:auto}.close.svelte-yxa4ka{display:block;box-sizing:border-box;position:absolute;z-index:1000;top:1rem;right:1rem;margin:0;padding:0;width:1.5rem;height:1.5rem;border:0;color:black;border-radius:1.5rem;background:white;box-shadow:0 0 0 1px black;transition:transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1),\n      background 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);-webkit-appearance:none}.close.svelte-yxa4ka:before,.close.svelte-yxa4ka:after{content:'';display:block;box-sizing:border-box;position:absolute;top:50%;width:1rem;height:1px;background:black;transform-origin:center;transition:height 0.2s cubic-bezier(0.25, 0.1, 0.25, 1),\n      background 0.2s cubic-bezier(0.25, 0.1, 0.25, 1)}.close.svelte-yxa4ka:before{transform:translate(0, -50%) rotate(45deg);left:0.25rem}.close.svelte-yxa4ka:after{transform:translate(0, -50%) rotate(-45deg);left:0.25rem}.close.svelte-yxa4ka:hover{background:black}.close.svelte-yxa4ka:hover:before,.close.svelte-yxa4ka:hover:after{height:2px;background:white}.close.svelte-yxa4ka:focus{border-color:#3399ff;box-shadow:0 0 0 2px #3399ff}.close.svelte-yxa4ka:active{transform:scale(0.9)}.close.svelte-yxa4ka:hover,.close.svelte-yxa4ka:focus,.close.svelte-yxa4ka:active{outline:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function create_if_block(ctx) {
  let div3;
  let div2;
  let div1;
  let t;
  let div0;
  let switch_instance;
  let div0_class_value;
  let div1_class_value;
  let div1_aria_label_value;
  let div1_aria_labelledby_value;
  let div1_transition;
  let div2_class_value;
  let div3_id_value;
  let div3_class_value;
  let div3_transition;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*state*/
    ctx[1].closeButton && create_if_block_1(ctx)
  );
  var switch_value = (
    /*Component*/
    ctx[2]
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr_dev(div0, "class", div0_class_value = null_to_empty(
        /*state*/
        ctx[1].classContent
      ) + " svelte-yxa4ka");
      attr_dev(
        div0,
        "style",
        /*cssContent*/
        ctx[9]
      );
      toggle_class(div0, "content", !/*unstyled*/
      ctx[0]);
      add_location(div0, file, 514, 8, 14163);
      attr_dev(div1, "class", div1_class_value = null_to_empty(
        /*state*/
        ctx[1].classWindow
      ) + " svelte-yxa4ka");
      attr_dev(div1, "role", "dialog");
      attr_dev(div1, "aria-modal", "true");
      attr_dev(div1, "aria-label", div1_aria_label_value = /*state*/
      ctx[1].ariaLabelledBy ? null : (
        /*state*/
        ctx[1].ariaLabel || null
      ));
      attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value = /*state*/
      ctx[1].ariaLabelledBy || null);
      attr_dev(
        div1,
        "style",
        /*cssWindow*/
        ctx[8]
      );
      toggle_class(div1, "window", !/*unstyled*/
      ctx[0]);
      add_location(div1, file, 485, 6, 13188);
      attr_dev(div2, "class", div2_class_value = null_to_empty(
        /*state*/
        ctx[1].classWindowWrap
      ) + " svelte-yxa4ka");
      attr_dev(
        div2,
        "style",
        /*cssWindowWrap*/
        ctx[7]
      );
      toggle_class(div2, "wrap", !/*unstyled*/
      ctx[0]);
      add_location(div2, file, 479, 4, 13055);
      attr_dev(div3, "id", div3_id_value = /*state*/
      ctx[1].id);
      attr_dev(div3, "class", div3_class_value = null_to_empty(
        /*state*/
        ctx[1].classBg
      ) + " svelte-yxa4ka");
      attr_dev(
        div3,
        "style",
        /*cssBg*/
        ctx[6]
      );
      toggle_class(div3, "bg", !/*unstyled*/
      ctx[0]);
      add_location(div3, file, 469, 2, 12791);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div2);
      append_dev(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t);
      append_dev(div1, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      ctx[50](div1);
      ctx[51](div2);
      ctx[52](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "introstart",
            function() {
              if (is_function(
                /*onOpen*/
                ctx[13]
              ))
                ctx[13].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "outrostart",
            function() {
              if (is_function(
                /*onClose*/
                ctx[14]
              ))
                ctx[14].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "introend",
            function() {
              if (is_function(
                /*onOpened*/
                ctx[15]
              ))
                ctx[15].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "outroend",
            function() {
              if (is_function(
                /*onClosed*/
                ctx[16]
              ))
                ctx[16].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mousedown",
            /*handleOuterMousedown*/
            ctx[20],
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "mouseup",
            /*handleOuterMouseup*/
            ctx[21],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*state*/
        ctx[1].closeButton
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*state*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (switch_value !== (switch_value = /*Component*/
      ctx[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty[0] & /*state*/
      2 && div0_class_value !== (div0_class_value = null_to_empty(
        /*state*/
        ctx[1].classContent
      ) + " svelte-yxa4ka")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*cssContent*/
      512) {
        attr_dev(
          div0,
          "style",
          /*cssContent*/
          ctx[9]
        );
      }
      if (!current || dirty[0] & /*state, unstyled*/
      3) {
        toggle_class(div0, "content", !/*unstyled*/
        ctx[0]);
      }
      if (!current || dirty[0] & /*state*/
      2 && div1_class_value !== (div1_class_value = null_to_empty(
        /*state*/
        ctx[1].classWindow
      ) + " svelte-yxa4ka")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*state*/
      2 && div1_aria_label_value !== (div1_aria_label_value = /*state*/
      ctx[1].ariaLabelledBy ? null : (
        /*state*/
        ctx[1].ariaLabel || null
      ))) {
        attr_dev(div1, "aria-label", div1_aria_label_value);
      }
      if (!current || dirty[0] & /*state*/
      2 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = /*state*/
      ctx[1].ariaLabelledBy || null)) {
        attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value);
      }
      if (!current || dirty[0] & /*cssWindow*/
      256) {
        attr_dev(
          div1,
          "style",
          /*cssWindow*/
          ctx[8]
        );
      }
      if (!current || dirty[0] & /*state, unstyled*/
      3) {
        toggle_class(div1, "window", !/*unstyled*/
        ctx[0]);
      }
      if (!current || dirty[0] & /*state*/
      2 && div2_class_value !== (div2_class_value = null_to_empty(
        /*state*/
        ctx[1].classWindowWrap
      ) + " svelte-yxa4ka")) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*cssWindowWrap*/
      128) {
        attr_dev(
          div2,
          "style",
          /*cssWindowWrap*/
          ctx[7]
        );
      }
      if (!current || dirty[0] & /*state, unstyled*/
      3) {
        toggle_class(div2, "wrap", !/*unstyled*/
        ctx[0]);
      }
      if (!current || dirty[0] & /*state*/
      2 && div3_id_value !== (div3_id_value = /*state*/
      ctx[1].id)) {
        attr_dev(div3, "id", div3_id_value);
      }
      if (!current || dirty[0] & /*state*/
      2 && div3_class_value !== (div3_class_value = null_to_empty(
        /*state*/
        ctx[1].classBg
      ) + " svelte-yxa4ka")) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*cssBg*/
      64) {
        attr_dev(
          div3,
          "style",
          /*cssBg*/
          ctx[6]
        );
      }
      if (!current || dirty[0] & /*state, unstyled*/
      3) {
        toggle_class(div3, "bg", !/*unstyled*/
        ctx[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      add_render_callback(() => {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(
            div1,
            /*currentTransitionWindow*/
            ctx[12],
            /*state*/
            ctx[1].transitionWindowProps,
            true
          );
        div1_transition.run(1);
      });
      add_render_callback(() => {
        if (!div3_transition)
          div3_transition = create_bidirectional_transition(
            div3,
            /*currentTransitionBg*/
            ctx[11],
            /*state*/
            ctx[1].transitionBgProps,
            true
          );
        div3_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(
          div1,
          /*currentTransitionWindow*/
          ctx[12],
          /*state*/
          ctx[1].transitionWindowProps,
          false
        );
      div1_transition.run(0);
      if (!div3_transition)
        div3_transition = create_bidirectional_transition(
          div3,
          /*currentTransitionBg*/
          ctx[11],
          /*state*/
          ctx[1].transitionBgProps,
          false
        );
      div3_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (if_block)
        if_block.d();
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[50](null);
      if (detaching && div1_transition)
        div1_transition.end();
      ctx[51](null);
      ctx[52](null);
      if (detaching && div3_transition)
        div3_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(469:0) {#if Component}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & /*state*/
    2)
      show_if = null;
    if (show_if == null)
      show_if = !!/*isFunction*/
      ctx2[17](
        /*state*/
        ctx2[1].closeButton
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(501:8) {#if state.closeButton}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let button;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      attr_dev(button, "class", button_class_value = null_to_empty(
        /*state*/
        ctx[1].classCloseButton
      ) + " svelte-yxa4ka");
      attr_dev(button, "aria-label", "Close modal");
      attr_dev(
        button,
        "style",
        /*cssCloseButton*/
        ctx[10]
      );
      attr_dev(button, "type", "button");
      toggle_class(button, "close", !/*unstyled*/
      ctx[0]);
      add_location(button, file, 504, 12, 13884);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*close*/
          ctx[18],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*state*/
      2 && button_class_value !== (button_class_value = null_to_empty(
        /*state*/
        ctx2[1].classCloseButton
      ) + " svelte-yxa4ka")) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & /*cssCloseButton*/
      1024) {
        attr_dev(
          button,
          "style",
          /*cssCloseButton*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*state, unstyled*/
      3) {
        toggle_class(button, "close", !/*unstyled*/
        ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(504:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*state*/
    ctx[1].closeButton
  );
  function switch_props(ctx2) {
    return {
      props: { onClose: (
        /*close*/
        ctx2[18]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = /*state*/
      ctx2[1].closeButton)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(502:10) {#if isFunction(state.closeButton)}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*Component*/
    ctx[2] && create_if_block(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[49].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[48],
    null
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window_1,
          "keydown",
          /*handleKeydown*/
          ctx[19],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*Component*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*Component*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[48],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[48]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[48],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function bind(Component, props = {}) {
  return function ModalComponent(options) {
    return new Component({
      ...options,
      props: { ...props, ...options.props }
    });
  };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["default"]);
  const dispatch = createEventDispatcher();
  const baseSetContext = setContext;
  const baseIsTabbable = (node) => node.tabIndex >= 0 && !node.hidden && !node.disabled && node.style.display !== "none" && node.type !== "hidden" && Boolean(node.offsetWidth || node.offsetHeight || node.getClientRects().length);
  let { isTabbable = baseIsTabbable } = $$props;
  let { show = null } = $$props;
  let { id = null } = $$props;
  let { key = "simple-modal" } = $$props;
  let { ariaLabel = null } = $$props;
  let { ariaLabelledBy = null } = $$props;
  let { closeButton = true } = $$props;
  let { closeOnEsc = true } = $$props;
  let { closeOnOuterClick = true } = $$props;
  let { styleBg = {} } = $$props;
  let { styleWindowWrap = {} } = $$props;
  let { styleWindow = {} } = $$props;
  let { styleContent = {} } = $$props;
  let { styleCloseButton = {} } = $$props;
  let { classBg = null } = $$props;
  let { classWindowWrap = null } = $$props;
  let { classWindow = null } = $$props;
  let { classContent = null } = $$props;
  let { classCloseButton = null } = $$props;
  let { unstyled = false } = $$props;
  let { setContext: setContext2 = baseSetContext } = $$props;
  let { transitionBg = fade } = $$props;
  let { transitionBgProps = { duration: 250 } } = $$props;
  let { transitionWindow = transitionBg } = $$props;
  let { transitionWindowProps = transitionBgProps } = $$props;
  let { disableFocusTrap = false } = $$props;
  const defaultState = {
    id,
    ariaLabel,
    ariaLabelledBy,
    closeButton,
    closeOnEsc,
    closeOnOuterClick,
    styleBg,
    styleWindowWrap,
    styleWindow,
    styleContent,
    styleCloseButton,
    classBg,
    classWindowWrap,
    classWindow,
    classContent,
    classCloseButton,
    transitionBg,
    transitionBgProps,
    transitionWindow,
    transitionWindowProps,
    disableFocusTrap,
    isTabbable,
    unstyled
  };
  let state = { ...defaultState };
  let Component = null;
  let background;
  let wrap;
  let modalWindow;
  let scrollY;
  let cssBg;
  let cssWindowWrap;
  let cssWindow;
  let cssContent;
  let cssCloseButton;
  let currentTransitionBg;
  let currentTransitionWindow;
  let prevBodyPosition;
  let prevBodyOverflow;
  let prevBodyWidth;
  let outerClickTarget;
  const camelCaseToDash = (str) => str.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();
  const toCssString = (props) => props ? Object.keys(props).reduce((str, key2) => `${str}; ${camelCaseToDash(key2)}: ${props[key2]}`, "") : "";
  const isFunction = (f) => !!(f && f.constructor && f.call && f.apply);
  const updateStyleTransition = () => {
    $$invalidate(6, cssBg = toCssString(Object.assign(
      {},
      {
        width: window.innerWidth,
        height: window.innerHeight
      },
      state.styleBg
    )));
    $$invalidate(7, cssWindowWrap = toCssString(state.styleWindowWrap));
    $$invalidate(8, cssWindow = toCssString(state.styleWindow));
    $$invalidate(9, cssContent = toCssString(state.styleContent));
    $$invalidate(10, cssCloseButton = toCssString(state.styleCloseButton));
    $$invalidate(11, currentTransitionBg = state.transitionBg);
    $$invalidate(12, currentTransitionWindow = state.transitionWindow);
  };
  const toVoid = () => {
  };
  let onOpen = toVoid;
  let onClose = toVoid;
  let onOpened = toVoid;
  let onClosed = toVoid;
  const open = (NewComponent, newProps = {}, options = {}, callbacks = {}) => {
    $$invalidate(2, Component = bind(NewComponent, newProps));
    $$invalidate(1, state = { ...defaultState, ...options });
    updateStyleTransition();
    disableScroll();
    $$invalidate(13, onOpen = (event) => {
      if (callbacks.onOpen)
        callbacks.onOpen(event);
      dispatch("open");
      dispatch("opening");
    });
    $$invalidate(14, onClose = (event) => {
      if (callbacks.onClose)
        callbacks.onClose(event);
      dispatch("close");
      dispatch("closing");
    });
    $$invalidate(15, onOpened = (event) => {
      if (callbacks.onOpened)
        callbacks.onOpened(event);
      dispatch("opened");
    });
    $$invalidate(16, onClosed = (event) => {
      if (callbacks.onClosed)
        callbacks.onClosed(event);
      dispatch("closed");
    });
  };
  const close = (callbacks = {}) => {
    if (!Component)
      return;
    $$invalidate(14, onClose = callbacks.onClose || onClose);
    $$invalidate(16, onClosed = callbacks.onClosed || onClosed);
    $$invalidate(2, Component = null);
    enableScroll();
  };
  const handleKeydown = (event) => {
    if (state.closeOnEsc && Component && event.key === "Escape") {
      event.preventDefault();
      close();
    }
    if (Component && event.key === "Tab" && !state.disableFocusTrap) {
      const nodes = modalWindow.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter(state.isTabbable).sort((a, b) => a.tabIndex - b.tabIndex);
      let index = tabbable.indexOf(document.activeElement);
      if (index === -1 && event.shiftKey)
        index = 0;
      index += tabbable.length + (event.shiftKey ? -1 : 1);
      index %= tabbable.length;
      tabbable[index].focus();
      event.preventDefault();
    }
  };
  const handleOuterMousedown = (event) => {
    if (state.closeOnOuterClick && (event.target === background || event.target === wrap))
      outerClickTarget = event.target;
  };
  const handleOuterMouseup = (event) => {
    if (state.closeOnOuterClick && event.target === outerClickTarget) {
      event.preventDefault();
      close();
    }
  };
  const disableScroll = () => {
    scrollY = window.scrollY;
    prevBodyPosition = document.body.style.position;
    prevBodyOverflow = document.body.style.overflow;
    prevBodyWidth = document.body.style.width;
    document.body.style.position = "fixed";
    document.body.style.top = `-${scrollY}px`;
    document.body.style.overflow = "hidden";
    document.body.style.width = "100%";
  };
  const enableScroll = () => {
    document.body.style.position = prevBodyPosition || "";
    document.body.style.top = "";
    document.body.style.overflow = prevBodyOverflow || "";
    document.body.style.width = prevBodyWidth || "";
    window.scrollTo({
      top: scrollY,
      left: 0,
      behavior: "instant"
    });
  };
  const context = { open, close };
  setContext2(key, context);
  let isMounted = false;
  onDestroy(() => {
    if (isMounted)
      close();
  });
  onMount(() => {
    $$invalidate(47, isMounted = true);
  });
  const writable_props = [
    "isTabbable",
    "show",
    "id",
    "key",
    "ariaLabel",
    "ariaLabelledBy",
    "closeButton",
    "closeOnEsc",
    "closeOnOuterClick",
    "styleBg",
    "styleWindowWrap",
    "styleWindow",
    "styleContent",
    "styleCloseButton",
    "classBg",
    "classWindowWrap",
    "classWindow",
    "classContent",
    "classCloseButton",
    "unstyled",
    "setContext",
    "transitionBg",
    "transitionBgProps",
    "transitionWindow",
    "transitionWindowProps",
    "disableFocusTrap"
  ];
  Object_1.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Modal> was created with unknown prop '${key2}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modalWindow = $$value;
      $$invalidate(5, modalWindow);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrap = $$value;
      $$invalidate(4, wrap);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      background = $$value;
      $$invalidate(3, background);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("isTabbable" in $$props2)
      $$invalidate(22, isTabbable = $$props2.isTabbable);
    if ("show" in $$props2)
      $$invalidate(23, show = $$props2.show);
    if ("id" in $$props2)
      $$invalidate(24, id = $$props2.id);
    if ("key" in $$props2)
      $$invalidate(25, key = $$props2.key);
    if ("ariaLabel" in $$props2)
      $$invalidate(26, ariaLabel = $$props2.ariaLabel);
    if ("ariaLabelledBy" in $$props2)
      $$invalidate(27, ariaLabelledBy = $$props2.ariaLabelledBy);
    if ("closeButton" in $$props2)
      $$invalidate(28, closeButton = $$props2.closeButton);
    if ("closeOnEsc" in $$props2)
      $$invalidate(29, closeOnEsc = $$props2.closeOnEsc);
    if ("closeOnOuterClick" in $$props2)
      $$invalidate(30, closeOnOuterClick = $$props2.closeOnOuterClick);
    if ("styleBg" in $$props2)
      $$invalidate(31, styleBg = $$props2.styleBg);
    if ("styleWindowWrap" in $$props2)
      $$invalidate(32, styleWindowWrap = $$props2.styleWindowWrap);
    if ("styleWindow" in $$props2)
      $$invalidate(33, styleWindow = $$props2.styleWindow);
    if ("styleContent" in $$props2)
      $$invalidate(34, styleContent = $$props2.styleContent);
    if ("styleCloseButton" in $$props2)
      $$invalidate(35, styleCloseButton = $$props2.styleCloseButton);
    if ("classBg" in $$props2)
      $$invalidate(36, classBg = $$props2.classBg);
    if ("classWindowWrap" in $$props2)
      $$invalidate(37, classWindowWrap = $$props2.classWindowWrap);
    if ("classWindow" in $$props2)
      $$invalidate(38, classWindow = $$props2.classWindow);
    if ("classContent" in $$props2)
      $$invalidate(39, classContent = $$props2.classContent);
    if ("classCloseButton" in $$props2)
      $$invalidate(40, classCloseButton = $$props2.classCloseButton);
    if ("unstyled" in $$props2)
      $$invalidate(0, unstyled = $$props2.unstyled);
    if ("setContext" in $$props2)
      $$invalidate(41, setContext2 = $$props2.setContext);
    if ("transitionBg" in $$props2)
      $$invalidate(42, transitionBg = $$props2.transitionBg);
    if ("transitionBgProps" in $$props2)
      $$invalidate(43, transitionBgProps = $$props2.transitionBgProps);
    if ("transitionWindow" in $$props2)
      $$invalidate(44, transitionWindow = $$props2.transitionWindow);
    if ("transitionWindowProps" in $$props2)
      $$invalidate(45, transitionWindowProps = $$props2.transitionWindowProps);
    if ("disableFocusTrap" in $$props2)
      $$invalidate(46, disableFocusTrap = $$props2.disableFocusTrap);
    if ("$$scope" in $$props2)
      $$invalidate(48, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    bind,
    svelte: svelte_exports,
    fade,
    createEventDispatcher,
    dispatch,
    baseSetContext,
    baseIsTabbable,
    isTabbable,
    show,
    id,
    key,
    ariaLabel,
    ariaLabelledBy,
    closeButton,
    closeOnEsc,
    closeOnOuterClick,
    styleBg,
    styleWindowWrap,
    styleWindow,
    styleContent,
    styleCloseButton,
    classBg,
    classWindowWrap,
    classWindow,
    classContent,
    classCloseButton,
    unstyled,
    setContext: setContext2,
    transitionBg,
    transitionBgProps,
    transitionWindow,
    transitionWindowProps,
    disableFocusTrap,
    defaultState,
    state,
    Component,
    background,
    wrap,
    modalWindow,
    scrollY,
    cssBg,
    cssWindowWrap,
    cssWindow,
    cssContent,
    cssCloseButton,
    currentTransitionBg,
    currentTransitionWindow,
    prevBodyPosition,
    prevBodyOverflow,
    prevBodyWidth,
    outerClickTarget,
    camelCaseToDash,
    toCssString,
    isFunction,
    updateStyleTransition,
    toVoid,
    onOpen,
    onClose,
    onOpened,
    onClosed,
    open,
    close,
    handleKeydown,
    handleOuterMousedown,
    handleOuterMouseup,
    disableScroll,
    enableScroll,
    context,
    isMounted
  });
  $$self.$inject_state = ($$props2) => {
    if ("isTabbable" in $$props2)
      $$invalidate(22, isTabbable = $$props2.isTabbable);
    if ("show" in $$props2)
      $$invalidate(23, show = $$props2.show);
    if ("id" in $$props2)
      $$invalidate(24, id = $$props2.id);
    if ("key" in $$props2)
      $$invalidate(25, key = $$props2.key);
    if ("ariaLabel" in $$props2)
      $$invalidate(26, ariaLabel = $$props2.ariaLabel);
    if ("ariaLabelledBy" in $$props2)
      $$invalidate(27, ariaLabelledBy = $$props2.ariaLabelledBy);
    if ("closeButton" in $$props2)
      $$invalidate(28, closeButton = $$props2.closeButton);
    if ("closeOnEsc" in $$props2)
      $$invalidate(29, closeOnEsc = $$props2.closeOnEsc);
    if ("closeOnOuterClick" in $$props2)
      $$invalidate(30, closeOnOuterClick = $$props2.closeOnOuterClick);
    if ("styleBg" in $$props2)
      $$invalidate(31, styleBg = $$props2.styleBg);
    if ("styleWindowWrap" in $$props2)
      $$invalidate(32, styleWindowWrap = $$props2.styleWindowWrap);
    if ("styleWindow" in $$props2)
      $$invalidate(33, styleWindow = $$props2.styleWindow);
    if ("styleContent" in $$props2)
      $$invalidate(34, styleContent = $$props2.styleContent);
    if ("styleCloseButton" in $$props2)
      $$invalidate(35, styleCloseButton = $$props2.styleCloseButton);
    if ("classBg" in $$props2)
      $$invalidate(36, classBg = $$props2.classBg);
    if ("classWindowWrap" in $$props2)
      $$invalidate(37, classWindowWrap = $$props2.classWindowWrap);
    if ("classWindow" in $$props2)
      $$invalidate(38, classWindow = $$props2.classWindow);
    if ("classContent" in $$props2)
      $$invalidate(39, classContent = $$props2.classContent);
    if ("classCloseButton" in $$props2)
      $$invalidate(40, classCloseButton = $$props2.classCloseButton);
    if ("unstyled" in $$props2)
      $$invalidate(0, unstyled = $$props2.unstyled);
    if ("setContext" in $$props2)
      $$invalidate(41, setContext2 = $$props2.setContext);
    if ("transitionBg" in $$props2)
      $$invalidate(42, transitionBg = $$props2.transitionBg);
    if ("transitionBgProps" in $$props2)
      $$invalidate(43, transitionBgProps = $$props2.transitionBgProps);
    if ("transitionWindow" in $$props2)
      $$invalidate(44, transitionWindow = $$props2.transitionWindow);
    if ("transitionWindowProps" in $$props2)
      $$invalidate(45, transitionWindowProps = $$props2.transitionWindowProps);
    if ("disableFocusTrap" in $$props2)
      $$invalidate(46, disableFocusTrap = $$props2.disableFocusTrap);
    if ("state" in $$props2)
      $$invalidate(1, state = $$props2.state);
    if ("Component" in $$props2)
      $$invalidate(2, Component = $$props2.Component);
    if ("background" in $$props2)
      $$invalidate(3, background = $$props2.background);
    if ("wrap" in $$props2)
      $$invalidate(4, wrap = $$props2.wrap);
    if ("modalWindow" in $$props2)
      $$invalidate(5, modalWindow = $$props2.modalWindow);
    if ("scrollY" in $$props2)
      scrollY = $$props2.scrollY;
    if ("cssBg" in $$props2)
      $$invalidate(6, cssBg = $$props2.cssBg);
    if ("cssWindowWrap" in $$props2)
      $$invalidate(7, cssWindowWrap = $$props2.cssWindowWrap);
    if ("cssWindow" in $$props2)
      $$invalidate(8, cssWindow = $$props2.cssWindow);
    if ("cssContent" in $$props2)
      $$invalidate(9, cssContent = $$props2.cssContent);
    if ("cssCloseButton" in $$props2)
      $$invalidate(10, cssCloseButton = $$props2.cssCloseButton);
    if ("currentTransitionBg" in $$props2)
      $$invalidate(11, currentTransitionBg = $$props2.currentTransitionBg);
    if ("currentTransitionWindow" in $$props2)
      $$invalidate(12, currentTransitionWindow = $$props2.currentTransitionWindow);
    if ("prevBodyPosition" in $$props2)
      prevBodyPosition = $$props2.prevBodyPosition;
    if ("prevBodyOverflow" in $$props2)
      prevBodyOverflow = $$props2.prevBodyOverflow;
    if ("prevBodyWidth" in $$props2)
      prevBodyWidth = $$props2.prevBodyWidth;
    if ("outerClickTarget" in $$props2)
      outerClickTarget = $$props2.outerClickTarget;
    if ("onOpen" in $$props2)
      $$invalidate(13, onOpen = $$props2.onOpen);
    if ("onClose" in $$props2)
      $$invalidate(14, onClose = $$props2.onClose);
    if ("onOpened" in $$props2)
      $$invalidate(15, onOpened = $$props2.onOpened);
    if ("onClosed" in $$props2)
      $$invalidate(16, onClosed = $$props2.onClosed);
    if ("isMounted" in $$props2)
      $$invalidate(47, isMounted = $$props2.isMounted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*show*/
    8388608 | $$self.$$.dirty[1] & /*isMounted*/
    65536) {
      $: {
        if (isMounted) {
          if (isFunction(show)) {
            open(show);
          } else {
            close();
          }
        }
      }
    }
  };
  return [
    unstyled,
    state,
    Component,
    background,
    wrap,
    modalWindow,
    cssBg,
    cssWindowWrap,
    cssWindow,
    cssContent,
    cssCloseButton,
    currentTransitionBg,
    currentTransitionWindow,
    onOpen,
    onClose,
    onOpened,
    onClosed,
    isFunction,
    close,
    handleKeydown,
    handleOuterMousedown,
    handleOuterMouseup,
    isTabbable,
    show,
    id,
    key,
    ariaLabel,
    ariaLabelledBy,
    closeButton,
    closeOnEsc,
    closeOnOuterClick,
    styleBg,
    styleWindowWrap,
    styleWindow,
    styleContent,
    styleCloseButton,
    classBg,
    classWindowWrap,
    classWindow,
    classContent,
    classCloseButton,
    setContext2,
    transitionBg,
    transitionBgProps,
    transitionWindow,
    transitionWindowProps,
    disableFocusTrap,
    isMounted,
    $$scope,
    slots,
    div1_binding,
    div2_binding,
    div3_binding
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        isTabbable: 22,
        show: 23,
        id: 24,
        key: 25,
        ariaLabel: 26,
        ariaLabelledBy: 27,
        closeButton: 28,
        closeOnEsc: 29,
        closeOnOuterClick: 30,
        styleBg: 31,
        styleWindowWrap: 32,
        styleWindow: 33,
        styleContent: 34,
        styleCloseButton: 35,
        classBg: 36,
        classWindowWrap: 37,
        classWindow: 38,
        classContent: 39,
        classCloseButton: 40,
        unstyled: 0,
        setContext: 41,
        transitionBg: 42,
        transitionBgProps: 43,
        transitionWindow: 44,
        transitionWindowProps: 45,
        disableFocusTrap: 46
      },
      add_css,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment.name
    });
  }
  get isTabbable() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isTabbable(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get show() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set show(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabelledBy() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabelledBy(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButton() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButton(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEsc() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEsc(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnOuterClick() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOuterClick(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleBg() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleBg(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleWindowWrap() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleWindowWrap(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleWindow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleWindow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleContent() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleContent(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleCloseButton() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleCloseButton(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classBg() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classBg(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classWindowWrap() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classWindowWrap(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classWindow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classWindow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classContent() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classContent(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classCloseButton() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classCloseButton(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unstyled() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unstyled(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setContext() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set setContext(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionBg() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionBg(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionBgProps() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionBgProps(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionWindow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionWindow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionWindowProps() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionWindowProps(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableFocusTrap() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableFocusTrap(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/svelte-simple-modal/src/index.js
var src_default = Modal_default;
export {
  Modal_default as Modal,
  bind,
  src_default as default
};
//# sourceMappingURL=svelte-simple-modal.js.map
