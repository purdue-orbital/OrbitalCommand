import {
  writable
} from "./chunk-X37OMW2E.js";
import "./chunk-OSHTMI7F.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_styles,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  createEventDispatcher,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-ADH6JJW2.js";

// node_modules/@beyonk/svelte-mapbox/mapbox.js
var contextKey = {};

// node_modules/@beyonk/svelte-mapbox/asset-loader.js
function load(assets, cb) {
  for (const { type, value, id } of assets) {
    const existing = document.getElementById(id);
    if (existing) {
      if (type === "script") {
        cb();
      }
      return;
    }
    const tag = document.createElement(type);
    tag.id = id;
    if (type === "script") {
      tag.async = true;
      tag.defer = true;
      tag.src = value;
      tag.onload = () => cb();
    } else {
      tag.rel = "stylesheet";
      tag.href = value;
    }
    document.body.appendChild(tag);
  }
}

// node_modules/@beyonk/svelte-mapbox/event-bindings.js
function bindEvents(el, handlers3, mapbox, node) {
  const unbindings = [];
  for (const [handler, fn] of Object.entries(handlers3)) {
    const cmd = (ev) => {
      const [eventName, detail] = fn(el, ev, mapbox);
      node.dispatchEvent(
        new CustomEvent(eventName, { detail })
      );
    };
    el.on(handler, cmd);
    unbindings.push([handler, cmd]);
  }
  return () => {
    for (const [handler, cmd] of unbindings) {
      el.off(handler, cmd);
    }
  };
}

// node_modules/@beyonk/svelte-mapbox/map/map-action.js
function action(node, options = {}) {
  let map;
  const resources = [
    { type: "script", attr: "src", value: `//api.mapbox.com/mapbox-gl-js/${options.version}/mapbox-gl.js`, id: "byk-gl-js" },
    { type: "link", attr: "href", value: `//api.mapbox.com/mapbox-gl-js/${options.version}/mapbox-gl.css`, id: "byk-gl-css" }
  ];
  const customStylesheetUrl = options.customStylesheetUrl;
  if (customStylesheetUrl) {
    resources.push({ type: "link", attr: "href", value: customStylesheetUrl, id: "byk-mcsu-css" });
  }
  let unbind = () => {
  };
  load(resources, () => {
    unbind = init2({ ...options, container: node }, node);
  });
  return {
    destroy() {
      unbind();
      map && map.remove && map.remove();
    }
  };
}
function init2(options, node) {
  window.mapboxgl.accessToken = options.accessToken;
  const el = new window.mapboxgl.Map(options);
  return bindEvents(el, handlers, window.mapboxgl, node);
}
var handlers = {
  dragend: (el) => {
    return ["dragend", { center: el.getCenter() }];
  },
  drag: (el) => {
    return ["drag", { center: el.getCenter() }];
  },
  moveend: (el) => {
    return ["recentre", { center: el.getCenter() }];
  },
  click: (el, { lngLat }) => {
    return ["click", { lng: lngLat.lng, lat: lngLat.lat }];
  },
  zoomstart: (el) => {
    return ["zoomstart", { zoom: el.getZoom() }];
  },
  zoom: (el) => {
    return ["zoom", { zoom: el.getZoom() }];
  },
  zoomend: (el) => {
    return ["zoomend", { zoom: el.getZoom() }];
  },
  load: (el, ev, mapbox) => {
    return ["ready", { map: el, mapbox }];
  }
};

// node_modules/@beyonk/svelte-mapbox/queue.js
var EventQueue = class {
  constructor() {
    this.queue = writable([]);
    this.unsubscribe = null;
    this.started = false;
  }
  send(command, params = []) {
    if (!command) {
      return;
    }
    this.queue.update((q) => [...q, [command, params]]);
  }
  start(map) {
    this.unsubscribe = this.queue.subscribe((queue) => {
      while (queue.length) {
        const [command, params] = queue.shift();
        map[command].apply(map, params);
      }
    });
    this.started = true;
  }
  stop() {
    if (!this.started) {
      return;
    }
    this.unsubscribe();
    this.queue = writable([]);
    this.started = false;
  }
};

// node_modules/@beyonk/svelte-mapbox/map/Map.svelte
var { Object: Object_1 } = globals;
var file = "node_modules/@beyonk/svelte-mapbox/map/Map.svelte";
function add_css(target) {
  append_styles(target, "svelte-1kuj9kb", "div.svelte-1kuj9kb{width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFwLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFrQkUsR0FBQSxlQUFBLENBQUEsQUFDRSxLQUFBLENBQUEsSUFBVyxDQUNYLE1BQUEsQ0FBQSxJQUFZLEFBQ2QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNYXAuc3ZlbHRlIl19 */");
}
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(13:2) {#if map}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let action_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*map*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr_dev(div, "class", "svelte-1kuj9kb");
      add_location(div, file, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(action_action = action.call(
            null,
            div,
            /*optionsWithDefaults*/
            ctx[1]
          )),
          listen_dev(
            div,
            "ready",
            /*init*/
            ctx[2],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "recentre",
            /*recentre_handler*/
            ctx[22],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "dragend",
            /*dragend_handler*/
            ctx[23],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[24],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "zoomstart",
            /*zoomstart_handler*/
            ctx[25],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "zoom",
            /*zoom_handler*/
            ctx[26],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "zoomend",
            /*zoomend_handler*/
            ctx[27],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "drag",
            /*drag_handler*/
            ctx[28],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler*/
            ctx[29],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*map*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*map*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Map", slots, ["default"]);
  let { map = null } = $$props;
  let { version = "v2.12.0" } = $$props;
  let { center = [0, 0] } = $$props;
  let { zoom = 9 } = $$props;
  let { zoomRate = 1 } = $$props;
  let { wheelZoomRate = 1 } = $$props;
  let { options = {} } = $$props;
  let { accessToken } = $$props;
  let { customStylesheetUrl = false } = $$props;
  let { style = "mapbox://styles/mapbox/streets-v11" } = $$props;
  const dispatch = createEventDispatcher();
  setContext(contextKey, {
    getMap: () => map,
    getMapbox: () => mapbox
  });
  let container;
  let mapbox;
  const optionsWithDefaults = Object.assign(
    {
      accessToken,
      container,
      style,
      center,
      zoom,
      zoomRate,
      wheelZoomRate,
      version,
      customStylesheetUrl,
      map
    },
    options
  );
  const queue = new EventQueue();
  function init4({ detail }) {
    $$invalidate(0, map = detail.map);
    mapbox = detail.mapbox;
    queue.start(map);
    dispatch("ready");
  }
  onDestroy(() => {
    queue.stop();
    $$invalidate(0, map = void 0);
  });
  function fitBounds(bbox, data = {}) {
    queue.send("fitBounds", [bbox, data]);
  }
  function flyTo(destination, data = {}) {
    queue.send("flyTo", [destination, data]);
  }
  function resize() {
    queue.send("resize");
  }
  function setCenter(coords, data = {}) {
    queue.send("setCenter", [coords, data]);
  }
  function setZoom(value, data = {}) {
    queue.send("setZoom", [value, data]);
  }
  function addControl(control, position = "top-right") {
    queue.send("addControl", [control, position]);
  }
  function getMap() {
    return map;
  }
  function getMapbox() {
    return mapbox;
  }
  $$self.$$.on_mount.push(function() {
    if (accessToken === void 0 && !("accessToken" in $$props || $$self.$$.bound[$$self.$$.props["accessToken"]])) {
      console.warn("<Map> was created without expected prop 'accessToken'");
    }
  });
  const writable_props = [
    "map",
    "version",
    "center",
    "zoom",
    "zoomRate",
    "wheelZoomRate",
    "options",
    "accessToken",
    "customStylesheetUrl",
    "style"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Map> was created with unknown prop '${key}'`);
  });
  function recentre_handler(event) {
    bubble.call(this, $$self, event);
  }
  function dragend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function zoomstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function zoom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function zoomend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function drag_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("map" in $$props2)
      $$invalidate(0, map = $$props2.map);
    if ("version" in $$props2)
      $$invalidate(3, version = $$props2.version);
    if ("center" in $$props2)
      $$invalidate(4, center = $$props2.center);
    if ("zoom" in $$props2)
      $$invalidate(5, zoom = $$props2.zoom);
    if ("zoomRate" in $$props2)
      $$invalidate(6, zoomRate = $$props2.zoomRate);
    if ("wheelZoomRate" in $$props2)
      $$invalidate(7, wheelZoomRate = $$props2.wheelZoomRate);
    if ("options" in $$props2)
      $$invalidate(8, options = $$props2.options);
    if ("accessToken" in $$props2)
      $$invalidate(9, accessToken = $$props2.accessToken);
    if ("customStylesheetUrl" in $$props2)
      $$invalidate(10, customStylesheetUrl = $$props2.customStylesheetUrl);
    if ("style" in $$props2)
      $$invalidate(11, style = $$props2.style);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    onDestroy,
    createEventDispatcher,
    contextKey,
    action,
    EventQueue,
    map,
    version,
    center,
    zoom,
    zoomRate,
    wheelZoomRate,
    options,
    accessToken,
    customStylesheetUrl,
    style,
    dispatch,
    container,
    mapbox,
    optionsWithDefaults,
    queue,
    init: init4,
    fitBounds,
    flyTo,
    resize,
    setCenter,
    setZoom,
    addControl,
    getMap,
    getMapbox
  });
  $$self.$inject_state = ($$props2) => {
    if ("map" in $$props2)
      $$invalidate(0, map = $$props2.map);
    if ("version" in $$props2)
      $$invalidate(3, version = $$props2.version);
    if ("center" in $$props2)
      $$invalidate(4, center = $$props2.center);
    if ("zoom" in $$props2)
      $$invalidate(5, zoom = $$props2.zoom);
    if ("zoomRate" in $$props2)
      $$invalidate(6, zoomRate = $$props2.zoomRate);
    if ("wheelZoomRate" in $$props2)
      $$invalidate(7, wheelZoomRate = $$props2.wheelZoomRate);
    if ("options" in $$props2)
      $$invalidate(8, options = $$props2.options);
    if ("accessToken" in $$props2)
      $$invalidate(9, accessToken = $$props2.accessToken);
    if ("customStylesheetUrl" in $$props2)
      $$invalidate(10, customStylesheetUrl = $$props2.customStylesheetUrl);
    if ("style" in $$props2)
      $$invalidate(11, style = $$props2.style);
    if ("container" in $$props2)
      container = $$props2.container;
    if ("mapbox" in $$props2)
      mapbox = $$props2.mapbox;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*zoom*/
    32) {
      $:
        zoom && setZoom(zoom);
    }
  };
  return [
    map,
    optionsWithDefaults,
    init4,
    version,
    center,
    zoom,
    zoomRate,
    wheelZoomRate,
    options,
    accessToken,
    customStylesheetUrl,
    style,
    fitBounds,
    flyTo,
    resize,
    setCenter,
    setZoom,
    addControl,
    getMap,
    getMapbox,
    $$scope,
    slots,
    recentre_handler,
    dragend_handler,
    click_handler,
    zoomstart_handler,
    zoom_handler,
    zoomend_handler,
    drag_handler,
    keydown_handler
  ];
}
var Map = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        map: 0,
        version: 3,
        center: 4,
        zoom: 5,
        zoomRate: 6,
        wheelZoomRate: 7,
        options: 8,
        accessToken: 9,
        customStylesheetUrl: 10,
        style: 11,
        fitBounds: 12,
        flyTo: 13,
        resize: 14,
        setCenter: 15,
        setZoom: 16,
        addControl: 17,
        getMap: 18,
        getMapbox: 19
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Map",
      options,
      id: create_fragment.name
    });
  }
  get map() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set map(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get version() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set version(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get center() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set center(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoom() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoom(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomRate() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomRate(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wheelZoomRate() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wheelZoomRate(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accessToken() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accessToken(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customStylesheetUrl() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customStylesheetUrl(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitBounds() {
    return this.$$.ctx[12];
  }
  set fitBounds(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flyTo() {
    return this.$$.ctx[13];
  }
  set flyTo(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resize() {
    return this.$$.ctx[14];
  }
  set resize(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setCenter() {
    return this.$$.ctx[15];
  }
  set setCenter(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setZoom() {
    return this.$$.ctx[16];
  }
  set setZoom(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addControl() {
    return this.$$.ctx[17];
  }
  set addControl(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getMap() {
    return this.$$.ctx[18];
  }
  set getMap(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getMapbox() {
    return this.$$.ctx[19];
  }
  set getMapbox(value) {
    throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Map_default = Map;

// node_modules/@beyonk/svelte-mapbox/map/Marker.svelte
var { Object: Object_12 } = globals;
var file2 = "node_modules/@beyonk/svelte-mapbox/map/Marker.svelte";
var get_popup_slot_changes = (dirty) => ({});
var get_popup_slot_context = (ctx) => ({});
function create_fragment2(ctx) {
  let div0;
  let t;
  let div1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const popup_slot_template = (
    /*#slots*/
    ctx[15].popup
  );
  const popup_slot = create_slot(
    popup_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_popup_slot_context
  );
  const block = {
    c: function create() {
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      div1 = element("div");
      if (popup_slot)
        popup_slot.c();
      add_location(div0, file2, 66, 0, 1514);
      attr_dev(div1, "class", "popup");
      add_location(div1, file2, 70, 0, 1562);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div0, anchor);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[16](div0);
      insert_dev(target, t, anchor);
      insert_dev(target, div1, anchor);
      if (popup_slot) {
        popup_slot.m(div1, null);
      }
      ctx[17](div1);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (popup_slot) {
        if (popup_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            popup_slot,
            popup_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              popup_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_popup_slot_changes
            ),
            get_popup_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(popup_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(popup_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div0);
      if (default_slot)
        default_slot.d(detaching);
      ctx[16](null);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div1);
      if (popup_slot)
        popup_slot.d(detaching);
      ctx[17](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function randomColour() {
  return Math.round(Math.random() * 255);
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Marker", slots, ["default", "popup"]);
  const { getMap, getMapbox } = getContext(contextKey);
  const map = getMap();
  const mapbox = getMapbox();
  function move(lng2, lat2) {
    marker.setLngLat({ lng: lng2, lat: lat2 });
  }
  let { lat } = $$props;
  let { lng } = $$props;
  let { label = "Marker" } = $$props;
  let { popupClassName = "beyonk-mapbox-popup" } = $$props;
  let { markerOffset = [0, 0] } = $$props;
  let { popupOffset = 10 } = $$props;
  let { color = randomColour() } = $$props;
  let { popup = true } = $$props;
  let { popupOptions = {} } = $$props;
  let { markerOptions = {} } = $$props;
  let marker;
  let element2;
  let elementPopup;
  onMount(() => {
    const namedParams = Object.assign({ offset: markerOffset }, element2.hasChildNodes() ? { element: element2 } : { color });
    $$invalidate(13, marker = new mapbox.Marker(Object.assign(namedParams, markerOptions)));
    if (popup) {
      const namedPopupParams = {
        offset: popupOffset,
        className: popupClassName
      };
      const popupEl = new mapbox.Popup(Object.assign(namedPopupParams, popupOptions));
      if (elementPopup.hasChildNodes()) {
        popupEl.setDOMContent(elementPopup);
      } else {
        popupEl.setText(label);
      }
      marker.setPopup(popupEl);
    }
    marker.setLngLat({ lng, lat }).addTo(map);
    return () => marker.remove();
  });
  function getMarker() {
    return marker;
  }
  $$self.$$.on_mount.push(function() {
    if (lat === void 0 && !("lat" in $$props || $$self.$$.bound[$$self.$$.props["lat"]])) {
      console.warn("<Marker> was created without expected prop 'lat'");
    }
    if (lng === void 0 && !("lng" in $$props || $$self.$$.bound[$$self.$$.props["lng"]])) {
      console.warn("<Marker> was created without expected prop 'lng'");
    }
  });
  const writable_props = [
    "lat",
    "lng",
    "label",
    "popupClassName",
    "markerOffset",
    "popupOffset",
    "color",
    "popup",
    "popupOptions",
    "markerOptions"
  ];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Marker> was created with unknown prop '${key}'`);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementPopup = $$value;
      $$invalidate(1, elementPopup);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("lat" in $$props2)
      $$invalidate(2, lat = $$props2.lat);
    if ("lng" in $$props2)
      $$invalidate(3, lng = $$props2.lng);
    if ("label" in $$props2)
      $$invalidate(4, label = $$props2.label);
    if ("popupClassName" in $$props2)
      $$invalidate(5, popupClassName = $$props2.popupClassName);
    if ("markerOffset" in $$props2)
      $$invalidate(6, markerOffset = $$props2.markerOffset);
    if ("popupOffset" in $$props2)
      $$invalidate(7, popupOffset = $$props2.popupOffset);
    if ("color" in $$props2)
      $$invalidate(8, color = $$props2.color);
    if ("popup" in $$props2)
      $$invalidate(9, popup = $$props2.popup);
    if ("popupOptions" in $$props2)
      $$invalidate(10, popupOptions = $$props2.popupOptions);
    if ("markerOptions" in $$props2)
      $$invalidate(11, markerOptions = $$props2.markerOptions);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    getContext,
    contextKey,
    getMap,
    getMapbox,
    map,
    mapbox,
    randomColour,
    move,
    lat,
    lng,
    label,
    popupClassName,
    markerOffset,
    popupOffset,
    color,
    popup,
    popupOptions,
    markerOptions,
    marker,
    element: element2,
    elementPopup,
    getMarker
  });
  $$self.$inject_state = ($$props2) => {
    if ("lat" in $$props2)
      $$invalidate(2, lat = $$props2.lat);
    if ("lng" in $$props2)
      $$invalidate(3, lng = $$props2.lng);
    if ("label" in $$props2)
      $$invalidate(4, label = $$props2.label);
    if ("popupClassName" in $$props2)
      $$invalidate(5, popupClassName = $$props2.popupClassName);
    if ("markerOffset" in $$props2)
      $$invalidate(6, markerOffset = $$props2.markerOffset);
    if ("popupOffset" in $$props2)
      $$invalidate(7, popupOffset = $$props2.popupOffset);
    if ("color" in $$props2)
      $$invalidate(8, color = $$props2.color);
    if ("popup" in $$props2)
      $$invalidate(9, popup = $$props2.popup);
    if ("popupOptions" in $$props2)
      $$invalidate(10, popupOptions = $$props2.popupOptions);
    if ("markerOptions" in $$props2)
      $$invalidate(11, markerOptions = $$props2.markerOptions);
    if ("marker" in $$props2)
      $$invalidate(13, marker = $$props2.marker);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("elementPopup" in $$props2)
      $$invalidate(1, elementPopup = $$props2.elementPopup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*marker, lng, lat*/
    8204) {
      $:
        marker && move(lng, lat);
    }
  };
  return [
    element2,
    elementPopup,
    lat,
    lng,
    label,
    popupClassName,
    markerOffset,
    popupOffset,
    color,
    popup,
    popupOptions,
    markerOptions,
    getMarker,
    marker,
    $$scope,
    slots,
    div0_binding,
    div1_binding
  ];
}
var Marker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      lat: 2,
      lng: 3,
      label: 4,
      popupClassName: 5,
      markerOffset: 6,
      popupOffset: 7,
      color: 8,
      popup: 9,
      popupOptions: 10,
      markerOptions: 11,
      getMarker: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Marker",
      options,
      id: create_fragment2.name
    });
  }
  get lat() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lat(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lng() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lng(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get popupClassName() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set popupClassName(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerOffset() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerOffset(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get popupOffset() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set popupOffset(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get popup() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set popup(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get popupOptions() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set popupOptions(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get markerOptions() {
    throw new Error("<Marker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set markerOptions(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getMarker() {
    return this.$$.ctx[12];
  }
  set getMarker(value) {
    throw new Error("<Marker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Marker_default = Marker;

// node_modules/@beyonk/svelte-mapbox/geocoder/geocoder-action.js
function action2(node, options = {}) {
  let map;
  const resources = [
    { type: "script", value: `//api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/${options.version}/mapbox-gl-geocoder.min.js`, id: "byk-gc-js" },
    { type: "link", value: `//api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/${options.version}/mapbox-gl-geocoder.css`, id: "byk-gc-css" }
  ];
  const customStylesheetUrl = options.customStylesheetUrl;
  if (customStylesheetUrl) {
    resources.push({ type: "link", value: customStylesheetUrl, id: "byk-gcsu-css" });
  }
  let unbind = () => {
  };
  load(resources, () => {
    unbind = init3(options, node);
  });
  return {
    destroy() {
      unbind();
      map && map.remove && map.remove();
    }
  };
}
function init3(options, node) {
  const geocoder = new window.MapboxGeocoder(options);
  geocoder.addTo(`#${node.id}`);
  if (options.value) {
    geocoder.setInput(options.value);
  }
  return bindEvents(geocoder, handlers2, false, node);
}
var handlers2 = {
  results: (el, ev) => {
    return ["results", ev];
  },
  result: (el, ev) => {
    return ["result", ev];
  },
  loading: (el, ev) => {
    return ["loading", ev];
  },
  error: (el, ev) => {
    return ["error", ev];
  },
  clear: (el, ev) => {
    return ["clear", ev];
  },
  load: (el) => {
    return ["ready", { geocoder: el }];
  }
};

// node_modules/@beyonk/svelte-mapbox/geocoder/Geocoder.svelte
var { Object: Object_13 } = globals;
var file3 = "node_modules/@beyonk/svelte-mapbox/geocoder/Geocoder.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1k1b3t4", "div.svelte-1k1b3t4{padding:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2VvY29kZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRDRSxHQUFBLGVBQUEsQ0FBQSxBQUNFLE9BQUEsQ0FBQSxDQUFVLEFBQ1osQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJHZW9jb2Rlci5zdmVsdGUiXX0= */");
}
function create_fragment3(ctx) {
  let div;
  let action_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(
        div,
        "id",
        /*fieldId*/
        ctx[0]
      );
      attr_dev(div, "class", "svelte-1k1b3t4");
      add_location(div, file3, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(action_action = action2.call(
            null,
            div,
            /*optionsWithDefaults*/
            ctx[1]
          )),
          listen_dev(
            div,
            "ready",
            /*init*/
            ctx[2],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "results",
            /*results_handler*/
            ctx[11],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "result",
            /*result_handler*/
            ctx[12],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "loading",
            /*loading_handler*/
            ctx[13],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "error",
            /*error_handler*/
            ctx[14],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "clear",
            /*clear_handler*/
            ctx[15],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "load",
            /*load_handler*/
            ctx[16],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Geocoder", slots, []);
  let { accessToken } = $$props;
  let { options = {} } = $$props;
  let { version = "v4.5.1" } = $$props;
  let { types = [
    "country",
    "region",
    "postcode",
    "district",
    "place",
    "locality",
    "neighborhood",
    "address"
  ] } = $$props;
  let { placeholder = "Search" } = $$props;
  let { value = null } = $$props;
  let { customStylesheetUrl = false } = $$props;
  let { geocoder } = $$props;
  const dispatch = createEventDispatcher();
  const fieldId = "bsm-" + Math.random().toString(36).substring(6);
  const optionsWithDefaults = Object.assign(
    {
      version,
      accessToken,
      types: types.join(","),
      placeholder,
      customStylesheetUrl,
      value
    },
    options
  );
  function init4({ detail }) {
    $$invalidate(3, geocoder = detail.geocoder);
    dispatch("ready");
  }
  $$self.$$.on_mount.push(function() {
    if (accessToken === void 0 && !("accessToken" in $$props || $$self.$$.bound[$$self.$$.props["accessToken"]])) {
      console.warn("<Geocoder> was created without expected prop 'accessToken'");
    }
    if (geocoder === void 0 && !("geocoder" in $$props || $$self.$$.bound[$$self.$$.props["geocoder"]])) {
      console.warn("<Geocoder> was created without expected prop 'geocoder'");
    }
  });
  const writable_props = [
    "accessToken",
    "options",
    "version",
    "types",
    "placeholder",
    "value",
    "customStylesheetUrl",
    "geocoder"
  ];
  Object_13.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Geocoder> was created with unknown prop '${key}'`);
  });
  function results_handler(event) {
    bubble.call(this, $$self, event);
  }
  function result_handler(event) {
    bubble.call(this, $$self, event);
  }
  function loading_handler(event) {
    bubble.call(this, $$self, event);
  }
  function error_handler(event) {
    bubble.call(this, $$self, event);
  }
  function clear_handler(event) {
    bubble.call(this, $$self, event);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("accessToken" in $$props2)
      $$invalidate(4, accessToken = $$props2.accessToken);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
    if ("version" in $$props2)
      $$invalidate(6, version = $$props2.version);
    if ("types" in $$props2)
      $$invalidate(7, types = $$props2.types);
    if ("placeholder" in $$props2)
      $$invalidate(8, placeholder = $$props2.placeholder);
    if ("value" in $$props2)
      $$invalidate(9, value = $$props2.value);
    if ("customStylesheetUrl" in $$props2)
      $$invalidate(10, customStylesheetUrl = $$props2.customStylesheetUrl);
    if ("geocoder" in $$props2)
      $$invalidate(3, geocoder = $$props2.geocoder);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    action: action2,
    accessToken,
    options,
    version,
    types,
    placeholder,
    value,
    customStylesheetUrl,
    geocoder,
    dispatch,
    fieldId,
    optionsWithDefaults,
    init: init4
  });
  $$self.$inject_state = ($$props2) => {
    if ("accessToken" in $$props2)
      $$invalidate(4, accessToken = $$props2.accessToken);
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
    if ("version" in $$props2)
      $$invalidate(6, version = $$props2.version);
    if ("types" in $$props2)
      $$invalidate(7, types = $$props2.types);
    if ("placeholder" in $$props2)
      $$invalidate(8, placeholder = $$props2.placeholder);
    if ("value" in $$props2)
      $$invalidate(9, value = $$props2.value);
    if ("customStylesheetUrl" in $$props2)
      $$invalidate(10, customStylesheetUrl = $$props2.customStylesheetUrl);
    if ("geocoder" in $$props2)
      $$invalidate(3, geocoder = $$props2.geocoder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    fieldId,
    optionsWithDefaults,
    init4,
    geocoder,
    accessToken,
    options,
    version,
    types,
    placeholder,
    value,
    customStylesheetUrl,
    results_handler,
    result_handler,
    loading_handler,
    error_handler,
    clear_handler,
    load_handler
  ];
}
var Geocoder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        accessToken: 4,
        options: 5,
        version: 6,
        types: 7,
        placeholder: 8,
        value: 9,
        customStylesheetUrl: 10,
        geocoder: 3
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Geocoder",
      options,
      id: create_fragment3.name
    });
  }
  get accessToken() {
    throw new Error("<Geocoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accessToken(value) {
    throw new Error("<Geocoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Geocoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Geocoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get version() {
    throw new Error("<Geocoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set version(value) {
    throw new Error("<Geocoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get types() {
    throw new Error("<Geocoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set types(value) {
    throw new Error("<Geocoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Geocoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Geocoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Geocoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Geocoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customStylesheetUrl() {
    throw new Error("<Geocoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customStylesheetUrl(value) {
    throw new Error("<Geocoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geocoder() {
    throw new Error("<Geocoder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geocoder(value) {
    throw new Error("<Geocoder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Geocoder_default = Geocoder;

// node_modules/@beyonk/svelte-mapbox/map/controls/GeolocateControl.svelte
var file4 = "node_modules/@beyonk/svelte-mapbox/map/controls/GeolocateControl.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1pfu5h6", "div.svelte-1pfu5h6{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2VvbG9jYXRlQ29udHJvbC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0RDLEdBQUEsZUFBQSxDQUFBLEFBQU0sT0FBQSxDQUFBLElBQWEsQUFBRSxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkdlb2xvY2F0ZUNvbnRyb2wuc3ZlbHRlIl19 */");
}
function create_fragment4(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "svelte-1pfu5h6");
      add_location(div, file4, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      ctx[9](div);
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "error",
            /*error_handler*/
            ctx[4],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "geolocate",
            /*geolocate_handler*/
            ctx[5],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outofmaxbounds",
            /*outofmaxbounds_handler*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "trackuserlocationend",
            /*trackuserlocationend_handler*/
            ctx[7],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "trackuserlocationstart",
            /*trackuserlocationstart_handler*/
            ctx[8],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GeolocateControl", slots, []);
  const { getMap, getMapbox } = getContext(contextKey);
  const map = getMap();
  const mapbox = getMapbox();
  let { position = "top-left" } = $$props;
  let { options = {} } = $$props;
  let dispatcher;
  const handlers3 = {
    error: (el, ev) => {
      return ["error", ev];
    },
    geolocate: (el, ev) => {
      return ["geolocate", ev];
    },
    outofmaxbounds: (el, ev) => {
      return ["outofmaxbounds", ev];
    },
    trackuserlocationend: (el, ev) => {
      return ["trackuserlocationend", ev];
    },
    trackuserlocationstart: (el, ev) => {
      return ["trackuserlocationstart", ev];
    }
  };
  const geolocate = new mapbox.GeolocateControl(options);
  map.addControl(geolocate, position);
  onMount(() => {
    return bindEvents(geolocate, handlers3, mapbox, dispatcher);
  });
  function trigger() {
    geolocate.trigger();
  }
  const writable_props = ["position", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GeolocateControl> was created with unknown prop '${key}'`);
  });
  function error_handler(event) {
    bubble.call(this, $$self, event);
  }
  function geolocate_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outofmaxbounds_handler(event) {
    bubble.call(this, $$self, event);
  }
  function trackuserlocationend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function trackuserlocationstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dispatcher = $$value;
      $$invalidate(0, dispatcher);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("options" in $$props2)
      $$invalidate(2, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    contextKey,
    bindEvents,
    getMap,
    getMapbox,
    map,
    mapbox,
    position,
    options,
    dispatcher,
    handlers: handlers3,
    geolocate,
    trigger
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("options" in $$props2)
      $$invalidate(2, options = $$props2.options);
    if ("dispatcher" in $$props2)
      $$invalidate(0, dispatcher = $$props2.dispatcher);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    dispatcher,
    position,
    options,
    trigger,
    error_handler,
    geolocate_handler,
    outofmaxbounds_handler,
    trackuserlocationend_handler,
    trackuserlocationstart_handler,
    div_binding
  ];
}
var GeolocateControl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { position: 1, options: 2, trigger: 3 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GeolocateControl",
      options,
      id: create_fragment4.name
    });
  }
  get position() {
    throw new Error("<GeolocateControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<GeolocateControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<GeolocateControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<GeolocateControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trigger() {
    return this.$$.ctx[3];
  }
  set trigger(value) {
    throw new Error("<GeolocateControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GeolocateControl_default = GeolocateControl;

// node_modules/@beyonk/svelte-mapbox/map/controls/NavigationControl.svelte
function create_fragment5(ctx) {
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavigationControl", slots, []);
  const { getMap, getMapbox } = getContext(contextKey);
  const map = getMap();
  const mapbox = getMapbox();
  let { position = "top-right" } = $$props;
  let { options = {} } = $$props;
  const nav = new mapbox.NavigationControl(options);
  map.addControl(nav, position);
  const writable_props = ["position", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NavigationControl> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    getContext,
    contextKey,
    getMap,
    getMapbox,
    map,
    mapbox,
    position,
    options,
    nav
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [position, options];
}
var NavigationControl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { position: 0, options: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavigationControl",
      options,
      id: create_fragment5.name
    });
  }
  get position() {
    throw new Error("<NavigationControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<NavigationControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<NavigationControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<NavigationControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavigationControl_default = NavigationControl;

// node_modules/@beyonk/svelte-mapbox/map/controls/ScaleControl.svelte
var { Object: Object_14 } = globals;
function create_fragment6(ctx) {
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScaleControl", slots, []);
  const { getMap, getMapbox } = getContext(contextKey);
  const map = getMap();
  const mapbox = getMapbox();
  let { position = "bottom-right" } = $$props;
  let { options = {} } = $$props;
  const optionsWithDefaults = Object.assign({ maxWidth: 80, unit: "metric" }, options);
  const scale = new mapbox.ScaleControl(optionsWithDefaults);
  map.addControl(scale, position);
  const writable_props = ["position", "options"];
  Object_14.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScaleControl> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    getContext,
    contextKey,
    getMap,
    getMapbox,
    map,
    mapbox,
    position,
    options,
    optionsWithDefaults,
    scale
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [position, options];
}
var ScaleControl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { position: 0, options: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScaleControl",
      options,
      id: create_fragment6.name
    });
  }
  get position() {
    throw new Error("<ScaleControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<ScaleControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<ScaleControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ScaleControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScaleControl_default = ScaleControl;

// node_modules/@beyonk/svelte-mapbox/components.js
var controls = {
  GeolocateControl: GeolocateControl_default,
  NavigationControl: NavigationControl_default,
  ScaleControl: ScaleControl_default
};
export {
  Geocoder_default as Geocoder,
  Map_default as Map,
  Marker_default as Marker,
  contextKey,
  controls
};
//# sourceMappingURL=@beyonk_svelte-mapbox.js.map
